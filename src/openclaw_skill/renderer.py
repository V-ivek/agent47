from __future__ import annotations

import json
from datetime import date, datetime, timezone
from typing import Any
from uuid import UUID


def _iso(dt: datetime) -> str:
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc).isoformat()


def _json_default(value: Any) -> str:
    if isinstance(value, datetime):
        return _iso(value)
    if isinstance(value, date):
        return value.isoformat()
    if isinstance(value, UUID):
        return str(value)
    return str(value)


def _stable_json(value: Any) -> str:
    return json.dumps(
        value,
        sort_keys=True,
        separators=(",", ":"),
        ensure_ascii=False,
        default=_json_default,
    )


def _strip_trailing_ws(s: str) -> str:
    return "\n".join(line.rstrip() for line in s.split("\n"))


def render_memory_generated(
    *,
    workspace_id: str,
    memory_entries: list[dict[str, Any]],
    decisions: list[dict[str, Any]],
    tasks: list[dict[str, Any]],
    risks: list[dict[str, Any]],
    generated_at: datetime,
) -> str:
    """Render MEMORY.generated.md per EPIC-4.5 deterministic contract."""

    header = [
        "# Punk Records — Generated Memory",
        "",
        f"- workspace_id: `{workspace_id}`",
        f"- generated_at: `{_iso(generated_at)}`",
        "",
        "> This file is generated. Do not edit by hand.",
        "",
    ]

    # Filter: only PROMOTED, omit RETRACTED. Exclude EPHEMERAL from generated memory.
    filtered: list[dict[str, Any]] = []
    for e in memory_entries:
        status = (e.get("status") or "").lower()
        bucket = (e.get("bucket") or "").lower()
        if status == "retracted":
            continue
        if status != "promoted":
            continue
        if bucket == "ephemeral":
            continue
        filtered.append(e)

    def sort_key(e: dict[str, Any]):
        entry_id = str(e.get("entry_id") or e.get("id") or "")
        key = str(e.get("key") or e.get("title") or entry_id)
        return (
            key,
            str(e.get("promoted_at") or ""),
            entry_id,
        )

    filtered.sort(key=sort_key)

    mem_lines = ["## Promoted Memory", ""]
    if not filtered:
        mem_lines.append("- (none)")
    else:
        for e in filtered:
            entry_id = e.get("entry_id") or e.get("id") or ""
            key = e.get("key") or e.get("title") or ""
            value = e.get("value") if "value" in e else e.get("content")
            source_event_id = e.get("source_event_id") or ""
            promoted_at = e.get("promoted_at") or e.get("updated_at") or ""
            conf = e.get("confidence")
            conf_str = "" if conf is None else str(conf)

            if isinstance(value, (dict, list)):
                summary = _stable_json(value)
            elif value is None:
                summary = ""
            else:
                summary = str(value)

            mem_lines.append(f"- **{key}**: {summary}")
            mem_lines.append(
                "  - "
                f"id: `{entry_id}` | "
                f"source: `{source_event_id}` | "
                f"promoted: `{promoted_at}` | "
                f"conf: {conf_str}"
            )

    sections: list[str] = []

    sections.extend(mem_lines)
    sections.append("")

    def render_events_section(title: str, events: list[dict[str, Any]]):
        lines = [f"## {title}", ""]
        if not events:
            lines.append("- (none)")
        else:
            normalized_items: list[tuple[str, Any]] = []
            for ev in events:
                item: Any = ev
                if isinstance(ev, dict):
                    payload = ev.get("payload")
                    if payload is None and "payload_json" in ev:
                        payload_raw = ev.get("payload_json")
                        if isinstance(payload_raw, str):
                            try:
                                payload = json.loads(payload_raw)
                            except Exception:
                                payload = payload_raw
                    if payload is not None:
                        item = payload

                normalized_items.append((_stable_json(item), item))

            for _, item in sorted(normalized_items, key=lambda t: t[0]):
                lines.append(f"- {_stable_json(item)}")
        return lines

    sections.extend(render_events_section("Decisions", decisions))
    sections.append("")
    sections.extend(render_events_section("Active Tasks", tasks))
    sections.append("")
    sections.extend(render_events_section("Risks", risks))
    sections.append("")

    footer = ["---", "Generated by `clawderpunk sync-memory`."]

    out = "\n".join(header + sections + footer)
    out = _strip_trailing_ws(out)
    # Ensure single trailing newline
    if not out.endswith("\n"):
        out += "\n"
    return out


def render_daily_snapshot(
    *,
    workspace_id: str,
    context_pack: dict[str, Any],
    generated_at: datetime,
    day: date | None = None,
) -> str:
    """Daily snapshot can include ephemeral items; keep deterministic formatting."""

    day = day or generated_at.date()

    header = [
        f"# Punk Records — Daily Snapshot ({day.isoformat()})",
        "",
        f"- workspace_id: `{workspace_id}`",
        f"- generated_at: `{_iso(generated_at)}`",
        "",
        "> This file is generated. Do not edit by hand.",
        "",
        "## Context Pack (raw)",
        "",
        f"```json\n{_stable_json(context_pack)}\n```",
        "",
        "---",
        "Generated by `clawderpunk sync-memory`.",
    ]

    out = "\n".join(header)
    out = _strip_trailing_ws(out)
    if not out.endswith("\n"):
        out += "\n"
    return out
